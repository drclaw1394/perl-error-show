=head1 NAME

Error::ShowMe - Show code context of your syntax and runtime errors

=head1 SYNOPSIS

To check a file from the command line, add C<-MError::ShowMe> as the first
module to add:

	perl -MError::ShowMe path/to/file.pl

	perl -I my_lib -MError::ShowMe -MAnother::Module  path/to/file.pl another/file.pl ...


To programically show why a script failed to load

	use Error::ShowMe;

	my $path="path/to/file.pl";

	#With do:
	do $path;
	my $context=Error::ShowMe::context $path;

	#String eval
	eval my $string="$i+1/0";
	my $context=Error::ShowMe::context \$string;

	#With block eval
	eval { require $path };
	my $context=Error::ShowMe::context __FILE__;


=head1 DESCRIPTION

This module transforms basic perl errors and caller information into a more
meaningful context without effecting your execption handling. If you are
editing multiple files, across multiple modules, the line numbers alone don't
really show you what is wrong and can be rather confusing.

Feature rich execeptions classes (which this module does NOT supply) are great
for dumping call stacks. However, they only work if your code compiles in the
first place.  While you can use perl's -c flag to check syntax, it only gives
line numbers of any errors and maybe a few characters of the source file.


From the command line, this module can be used to check syntax of multiple
source files at once.  When used in code, it can inspect origins of errors, or
arbitary lines of code.

A handfull of options provided basic configuration of how many lines of code to
print before and after the target line, indenting  prefix etc.



=head1 API

=head2 Command Line usage (Syntax checking)

When included in a command line switch to perl C<-MError::ShowMe>, it syntax
checks all inputs files.  This can be used with or without the C<-c> switch.

It is important that it's the first C<-M> switch

	perl -MError::ShowMe  file1.pl file2.pl ...

Additional C<@INC> directories can also be used.

=head2 Programmic Usage


Simply bring L<Error::ShowMe> into your program with a use statement:

	use Error::ShowMe;

This provides two subroutines (not exported)C<Error::ShowMe::context> and C<Error::ShowMe::trace_context>

=head3 Error::ShowMe::context

	Error::ShowMe::context [options_pairs,] filename
	

Generates a string with the code surrounding a target line number from
C<filename>. This could be a manual line number specified with a C<line>
options, or it could be extracted from the C<error> option.

If C<filename> is a string, it is treated as path. The file at the path is
loaded and processed with the information from C<line> or C<error> options to
generate context.

If C<filename> is a reference to a scalar, it is dereferenced, the contents
used directly as the program source to process using C<line> or C<error>
options to generate context.

If no C<error> option is provided, the C<$@> variable is used to extract error
line numbers

A C<line> option will force context to be generated from that line, ignorning any errors.

=head3 Error::ShowMe::trace_context

	Error::ShowMe::trace_context [option_pairs,]

Repeatedly calls C<Error::ShowMe::context> for each level the call stack to
provide more information.  Each level is indented with multiples of the
C<indent> option. No filename is needed, as this is extraced from the caller.




=head1 WHY USE THIS MODULE

=over

=item Syntax Checking

If your code doesn't compile, you can't use a custom execption class can you.
This will provide context information on syntax error directly from the command
line and doesn't need to be a dependency of your code.

=item Syntax check multiple files

Multiple source files can be checked from the command line with formated output


=item Use the exception module you want to

This module doesn't get in the way of using nice execption classes during run
time. It suppliments them.

=back

=head1 EXAMPLE USAGE

=head2 Syntax Checking

The B<examples/file_syn_error1.pl> program has a syntax error. Check it by running:

	perl -MError::ShowMe examples/file_syn_error1.pl;


The output will be something like this:

	./file_syn_error1.pl
	"use" not allowed in expression at ./file_syn_error1.pl line 9, at end of line
	syntax error at ./file_syn_error1.pl line 9, near "adf
	use Socket"
	./file_syn_error1.pl had compilation errors.
	 4   my $time=time;
	 5   for(1..1000){
	 6   	print "$_\n";
	 7   }
	 8   adf
	 9=> use Socket;
	10   
	11   print "this will never work";


=head2 Stack Dump

The B<examples/ae_stack_trace.pl> program does a trace_context call to show all
the hierrachial call stack in executing a timer callback:

	use AnyEvent;
	use Error::ShowMe;

	my $cv=AE::cv;
	my $timer; $timer=AE::timer 1,0, sub {
		print STDERR Error::ShowMe::trace_context pre_lines=>10, post_lines=>10;
		$cv->send;
	};
	$cv->recv;

If you have AnyEvent installed, running the program will give an output similar
to to the following:

	ae_stack_trace.pl
	1   use AnyEvent;
	2   use Error::ShowMe;
	3
	4   my $cv=AE::cv;
	5   my $timer; $timer=AE::timer 0,0, sub {
	6   	print STDERR Error::ShowMe::trace_context pre_lines=>10, post_lines=>10;
	7   	$timer=undef;
	8   	$cv->send;
	9   };
	10=> $cv->recv;

	    /Users/drclaw/perl5/perlbrew/perls/perl-5.36.0/lib/site_perl/5.36.0/darwin-2level/AnyEvent.pm
	    2021   sub ready {
	    2022      $_[0]{_ae_sent}
	    2023   }
	    2024
	    2025   sub recv {
	    2026      unless ($_[0]{_ae_sent}) {
	    2027         $WAITING
	    2028            and Carp::croak "AnyEvent::CondVar: recursive blocking wait attempted";
	    2029
	    2030         local $WAITING = 1;
	    2031=>       $_[0]->_wait;
	    2032      }
	    2033
	    2034      $_[0]{_ae_croak}
	    2035         and Carp::croak $_[0]{_ae_croak};
	    2036
	    2037      wantarray
	    2038         ? @{ $_[0]{_ae_sent} }
	    2039         : $_[0]{_ae_sent}[0]
	    2040   }
	    2041

		/Users/drclaw/perl5/perlbrew/perls/perl-5.36.0/lib/site_perl/5.36.0/darwin-2level/AnyEvent/Impl/EV.pm
		78      my ($class, %arg) = @_;
		79
		80      EV::idle $arg{cb}
		81   }
		82
		83   sub _poll {
		84      EV::run EV::RUN_ONCE;
		85   }
		86
		87   sub AnyEvent::CondVar::Base::_wait {
		88=>    EV::run EV::RUN_ONCE until exists $_[0]{_ae_sent};
		89   }
		90
		91   #sub loop {
		92   #   EV::run;
		93   #}
		94
		95   =head1 SEE ALSO
		96
		97   L<AnyEvent>, L<EV>.
		98

		    /Users/drclaw/perl5/perlbrew/perls/perl-5.36.0/lib/site_perl/5.36.0/darwin-2level/AnyEvent/Impl/EV.pm
		    78      my ($class, %arg) = @_;
		    79
		    80      EV::idle $arg{cb}
		    81   }
		    82
		    83   sub _poll {
		    84      EV::run EV::RUN_ONCE;
		    85   }
		    86
		    87   sub AnyEvent::CondVar::Base::_wait {
		    88=>    EV::run EV::RUN_ONCE until exists $_[0]{_ae_sent};
		    89   }
		    90
		    91   #sub loop {
		    92   #   EV::run;
		    93   #}
		    94
		    95   =head1 SEE ALSO
		    96
		    97   L<AnyEvent>, L<EV>.
		    98

			ae_stack_trace.pl
			1   use AnyEvent;
			2   use Error::ShowMe;
			3
			4   my $cv=AE::cv;
			5   my $timer; $timer=AE::timer 0,0, sub {
			6=> 	print STDERR Error::ShowMe::trace_context pre_lines=>10, post_lines=>10;
			7   	$timer=undef;
			8   	$cv->send;
			9   };
			10   $cv->recv;




=head1 FUTURE WORK/TODO

=over 

=item Add format options from command line

=item Process syntax checks in parallel

=item JSON/HTML and other output formats

=item Make usable from a Language Server?

=item Colour terminal output

=item What would you like?

=back
